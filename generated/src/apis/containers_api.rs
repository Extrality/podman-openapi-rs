/*
 * Provides an API for the Libpod library
 *
 * This documentation describes the Podman v2.0 RESTful API. It replaces the Podman v1.0 API and was initially delivered along with Podman v2.0.  It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: some fields in the API response JSON are set as omitempty, which means that if there is no value set for them, they will not show up in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v3.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v3.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v3.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: podman@lists.podman.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed successes of method [`container_attach_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerAttachLibpodSuccess {
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_changes_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerChangesLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_checkpoint_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCheckpointLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_create_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCreateLibpodSuccess {
    Status201(models::ContainerCreate201Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerDeleteLibpodSuccess {
    Status200(Vec<models::LibpodContainersRmReport>),
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_exists_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExistsLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_export_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExportLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_healthcheck_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerHealthcheckLibpodSuccess {
    Status200(models::ContainerHealthcheckLibpod200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_init_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInitLibpodSuccess {
    Status204(),
    Status304(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInspectLibpodSuccess {
    Status200(models::ContainerInspectLibpod200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_kill_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerKillLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerListLibpodSuccess {
    Status200(Vec<models::ListContainer>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_logs_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerLogsLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_mount_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerMountLibpodSuccess {
    Status200(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_pause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPauseLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_prune_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPruneLibpodSuccess {
    Status200(Vec<models::LibpodContainersPruneReport>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_rename_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRenameLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_resize_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerResizeLibpodSuccess {
    Status200(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_restart_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestartLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_restore_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestoreLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_show_mounted_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerShowMountedLibpodSuccess {
    Status200(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_start_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStartLibpodSuccess {
    Status204(),
    Status304(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_stats_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStatsLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_stop_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStopLibpodSuccess {
    Status204(),
    Status304(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_top_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerTopLibpodSuccess {
    Status200(models::ContainerTop200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_unmount_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnmountLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_unpause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnpauseLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_wait_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerWaitLibpodSuccess {
    Status200(i32),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`containers_stats_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainersStatsAllLibpodSuccess {
    Status200(models::ContainersStatsAllLibpod200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`generate_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKubeLibpodSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`generate_systemd_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateSystemdLibpodSuccess {
    Status200(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`image_commit_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImageCommitLibpodSuccess {
    Status201(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`play_kube_down_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeDownLibpodSuccess {
    Status200(models::PlayKubeReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`play_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeLibpodSuccess {
    Status200(models::PlayKubeReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`put_container_archive_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutContainerArchiveLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_attach_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerAttachLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_changes_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerChangesLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_checkpoint_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCheckpointLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_create_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCreateLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerDeleteLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_exists_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExistsLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_export_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExportLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_healthcheck_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerHealthcheckLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_init_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInitLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInspectLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_kill_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerKillLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerListLibpodError {
    Status400(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_logs_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerLogsLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_mount_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerMountLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_pause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPauseLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_prune_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPruneLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_rename_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRenameLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_resize_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerResizeLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_restart_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestartLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_restore_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestoreLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_show_mounted_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerShowMountedLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_start_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStartLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_stats_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStatsLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_stop_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStopLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_top_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerTopLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_unmount_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnmountLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_unpause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnpauseLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_wait_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerWaitLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`containers_stats_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainersStatsAllLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKubeLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_systemd_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateSystemdLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`image_commit_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImageCommitLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`play_kube_down_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeDownLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`play_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_container_archive_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutContainerArchiveLibpodError {
    Status400(models::SystemAuth500Response),
    Status403(),
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// Hijacks the connection to forward the container's standard streams to the client.
pub async fn container_attach_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    stdin: Option<bool>,
) -> Result<ResponseContent<ContainerAttachLibpodSuccess>, Error<ContainerAttachLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_detach_keys = detach_keys;
    let p_query_logs = logs;
    let p_query_stream = stream;
    let p_query_stdout = stdout;
    let p_query_stderr = stderr;
    let p_query_stdin = stdin;

    let uri_str = format!(
        "{}/libpod/containers/{name}/attach",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_detach_keys {
        req_builder = req_builder.query(&[("detachKeys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_logs {
        req_builder = req_builder.query(&[("logs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdout {
        req_builder = req_builder.query(&[("stdout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stderr {
        req_builder = req_builder.query(&[("stderr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdin {
        req_builder = req_builder.query(&[("stdin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerAttachLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerAttachLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns which files in a container's filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted
pub async fn container_changes_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    parent: Option<&str>,
    diff_type: Option<&str>,
) -> Result<ResponseContent<ContainerChangesLibpodSuccess>, Error<ContainerChangesLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_parent = parent;
    let p_query_diff_type = diff_type;

    let uri_str = format!(
        "{}/libpod/containers/{name}/changes",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_parent {
        req_builder = req_builder.query(&[("parent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diff_type {
        req_builder = req_builder.query(&[("diffType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerChangesLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerChangesLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_checkpoint_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    keep: Option<bool>,
    leave_running: Option<bool>,
    tcp_established: Option<bool>,
    export: Option<bool>,
    ignore_root_fs: Option<bool>,
    print_stats: Option<bool>,
) -> Result<ResponseContent<ContainerCheckpointLibpodSuccess>, Error<ContainerCheckpointLibpodError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_keep = keep;
    let p_query_leave_running = leave_running;
    let p_query_tcp_established = tcp_established;
    let p_query_export = export;
    let p_query_ignore_root_fs = ignore_root_fs;
    let p_query_print_stats = print_stats;

    let uri_str = format!(
        "{}/libpod/containers/{name}/checkpoint",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_keep {
        req_builder = req_builder.query(&[("keep", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_leave_running {
        req_builder = req_builder.query(&[("leaveRunning", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tcp_established {
        req_builder = req_builder.query(&[("tcpEstablished", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_export {
        req_builder = req_builder.query(&[("export", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_root_fs {
        req_builder = req_builder.query(&[("ignoreRootFS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_print_stats {
        req_builder = req_builder.query(&[("printStats", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerCheckpointLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerCheckpointLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_create_libpod(
    configuration: &configuration::Configuration,
    create: Option<models::SpecGenerator>,
) -> Result<ResponseContent<ContainerCreateLibpodSuccess>, Error<ContainerCreateLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create = create;

    let uri_str = format!("{}/libpod/containers/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerCreateLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerCreateLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete container
pub async fn container_delete_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    depend: Option<bool>,
    force: Option<bool>,
    ignore: Option<bool>,
    timeout: Option<i32>,
    v: Option<bool>,
) -> Result<ResponseContent<ContainerDeleteLibpodSuccess>, Error<ContainerDeleteLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_depend = depend;
    let p_query_force = force;
    let p_query_ignore = ignore;
    let p_query_timeout = timeout;
    let p_query_v = v;

    let uri_str = format!(
        "{}/libpod/containers/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_depend {
        req_builder = req_builder.query(&[("depend", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore {
        req_builder = req_builder.query(&[("ignore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_v {
        req_builder = req_builder.query(&[("v", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerDeleteLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerDeleteLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Quick way to determine if a container exists by name or ID
pub async fn container_exists_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerExistsLibpodSuccess>, Error<ContainerExistsLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/exists",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerExistsLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerExistsLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Export the contents of a container as a tarball.
pub async fn container_export_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerExportLibpodSuccess>, Error<ContainerExportLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/export",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerExportLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerExportLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Execute the defined healthcheck and return information about the results
pub async fn container_healthcheck_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<
    ResponseContent<ContainerHealthcheckLibpodSuccess>,
    Error<ContainerHealthcheckLibpodError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/healthcheck",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerHealthcheckLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerHealthcheckLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Performs all tasks necessary for initializing the container but does not start the container.
pub async fn container_init_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerInitLibpodSuccess>, Error<ContainerInitLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/init",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerInitLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerInitLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return low-level information about a container.
pub async fn container_inspect_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    size: Option<bool>,
) -> Result<ResponseContent<ContainerInspectLibpodSuccess>, Error<ContainerInspectLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_size = size;

    let uri_str = format!(
        "{}/libpod/containers/{name}/json",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerInspectLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerInspectLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// send a signal to a container, defaults to killing the container
pub async fn container_kill_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    signal: Option<&str>,
) -> Result<ResponseContent<ContainerKillLibpodSuccess>, Error<ContainerKillLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_signal = signal;

    let uri_str = format!(
        "{}/libpod/containers/{name}/kill",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_signal {
        req_builder = req_builder.query(&[("signal", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerKillLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerKillLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of containers
pub async fn container_list_libpod(
    configuration: &configuration::Configuration,
    all: Option<bool>,
    limit: Option<i32>,
    pod: Option<bool>,
    size: Option<bool>,
    sync: Option<bool>,
    filters: Option<&str>,
) -> Result<ResponseContent<ContainerListLibpodSuccess>, Error<ContainerListLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_all = all;
    let p_query_limit = limit;
    let p_query_pod = pod;
    let p_query_size = size;
    let p_query_sync = sync;
    let p_query_filters = filters;

    let uri_str = format!("{}/libpod/containers/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pod {
        req_builder = req_builder.query(&[("pod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync {
        req_builder = req_builder.query(&[("sync", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerListLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerListLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get stdout and stderr logs from a container.
pub async fn container_logs_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<&str>,
    until: Option<&str>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ResponseContent<ContainerLogsLibpodSuccess>, Error<ContainerLogsLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_follow = follow;
    let p_query_stdout = stdout;
    let p_query_stderr = stderr;
    let p_query_since = since;
    let p_query_until = until;
    let p_query_timestamps = timestamps;
    let p_query_tail = tail;

    let uri_str = format!(
        "{}/libpod/containers/{name}/logs",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdout {
        req_builder = req_builder.query(&[("stdout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stderr {
        req_builder = req_builder.query(&[("stderr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_until {
        req_builder = req_builder.query(&[("until", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timestamps {
        req_builder = req_builder.query(&[("timestamps", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tail {
        req_builder = req_builder.query(&[("tail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerLogsLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerLogsLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mount a container to the filesystem
pub async fn container_mount_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerMountLibpodSuccess>, Error<ContainerMountLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/mount",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerMountLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerMountLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Use the cgroups freezer to suspend all processes in a container.
pub async fn container_pause_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerPauseLibpodSuccess>, Error<ContainerPauseLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/pause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerPauseLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerPauseLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove containers not in use
pub async fn container_prune_libpod(
    configuration: &configuration::Configuration,
    filters: Option<&str>,
) -> Result<ResponseContent<ContainerPruneLibpodSuccess>, Error<ContainerPruneLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filters = filters;

    let uri_str = format!("{}/libpod/containers/prune", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerPruneLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerPruneLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Change the name of an existing container.
pub async fn container_rename_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    name2: &str,
) -> Result<ResponseContent<ContainerRenameLibpodSuccess>, Error<ContainerRenameLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_name = name2;

    let uri_str = format!(
        "{}/libpod/containers/{name}/rename",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerRenameLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerRenameLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resize the terminal attached to a container (for use with Attach).
pub async fn container_resize_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    h: Option<i32>,
    w: Option<i32>,
) -> Result<ResponseContent<ContainerResizeLibpodSuccess>, Error<ContainerResizeLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_h = h;
    let p_query_w = w;

    let uri_str = format!(
        "{}/libpod/containers/{name}/resize",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_h {
        req_builder = req_builder.query(&[("h", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_w {
        req_builder = req_builder.query(&[("w", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerResizeLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerResizeLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_restart_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    t: Option<i32>,
) -> Result<ResponseContent<ContainerRestartLibpodSuccess>, Error<ContainerRestartLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_t = t;

    let uri_str = format!(
        "{}/libpod/containers/{name}/restart",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_t {
        req_builder = req_builder.query(&[("t", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerRestartLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerRestartLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Restore a container from a checkpoint.
pub async fn container_restore_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    name2: Option<&str>,
    keep: Option<bool>,
    leave_running: Option<bool>,
    tcp_established: Option<bool>,
    import: Option<bool>,
    ignore_root_fs: Option<bool>,
    ignore_static_ip: Option<bool>,
    ignore_static_mac: Option<bool>,
    print_stats: Option<bool>,
) -> Result<ResponseContent<ContainerRestoreLibpodSuccess>, Error<ContainerRestoreLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_name = name2;
    let p_query_keep = keep;
    let p_query_leave_running = leave_running;
    let p_query_tcp_established = tcp_established;
    let p_query_import = import;
    let p_query_ignore_root_fs = ignore_root_fs;
    let p_query_ignore_static_ip = ignore_static_ip;
    let p_query_ignore_static_mac = ignore_static_mac;
    let p_query_print_stats = print_stats;

    let uri_str = format!(
        "{}/libpod/containers/{name}/restore",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keep {
        req_builder = req_builder.query(&[("keep", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_leave_running {
        req_builder = req_builder.query(&[("leaveRunning", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tcp_established {
        req_builder = req_builder.query(&[("tcpEstablished", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_import {
        req_builder = req_builder.query(&[("import", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_root_fs {
        req_builder = req_builder.query(&[("ignoreRootFS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_static_ip {
        req_builder = req_builder.query(&[("ignoreStaticIP", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_static_mac {
        req_builder = req_builder.query(&[("ignoreStaticMAC", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_print_stats {
        req_builder = req_builder.query(&[("printStats", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerRestoreLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerRestoreLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lists all mounted containers mount points
pub async fn container_show_mounted_libpod(
    configuration: &configuration::Configuration,
) -> Result<
    ResponseContent<ContainerShowMountedLibpodSuccess>,
    Error<ContainerShowMountedLibpodError>,
> {
    let uri_str = format!("{}/libpod/containers/showmounted", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerShowMountedLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerShowMountedLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_start_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    detach_keys: Option<&str>,
) -> Result<ResponseContent<ContainerStartLibpodSuccess>, Error<ContainerStartLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_detach_keys = detach_keys;

    let uri_str = format!(
        "{}/libpod/containers/{name}/start",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_detach_keys {
        req_builder = req_builder.query(&[("detachKeys", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStartLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStartLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DEPRECATED. This endpoint will be removed with the next major release. Please use /libpod/containers/stats instead.
pub async fn container_stats_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    stream: Option<bool>,
) -> Result<ResponseContent<ContainerStatsLibpodSuccess>, Error<ContainerStatsLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_stream = stream;

    let uri_str = format!(
        "{}/libpod/containers/{name}/stats",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStatsLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStatsLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_stop_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    all: Option<bool>,
    timeout: Option<i32>,
    ignore: Option<bool>,
) -> Result<ResponseContent<ContainerStopLibpodSuccess>, Error<ContainerStopLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_all = all;
    let p_query_timeout = timeout;
    let p_query_ignore = ignore;

    let uri_str = format!(
        "{}/libpod/containers/{name}/stop",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore {
        req_builder = req_builder.query(&[("Ignore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStopLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStopLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List processes running inside a container
pub async fn container_top_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    stream: Option<bool>,
    delay: Option<i32>,
    ps_args: Option<&str>,
) -> Result<ResponseContent<ContainerTopLibpodSuccess>, Error<ContainerTopLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_stream = stream;
    let p_query_delay = delay;
    let p_query_ps_args = ps_args;

    let uri_str = format!(
        "{}/libpod/containers/{name}/top",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_delay {
        req_builder = req_builder.query(&[("delay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ps_args {
        req_builder = req_builder.query(&[("ps_args", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerTopLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerTopLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unmount a container from the filesystem
pub async fn container_unmount_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerUnmountLibpodSuccess>, Error<ContainerUnmountLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/unmount",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerUnmountLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerUnmountLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_unpause_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerUnpauseLibpodSuccess>, Error<ContainerUnpauseLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/containers/{name}/unpause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerUnpauseLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerUnpauseLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Wait on a container to met a given condition
pub async fn container_wait_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    condition: Option<Vec<String>>,
    interval: Option<&str>,
) -> Result<ResponseContent<ContainerWaitLibpodSuccess>, Error<ContainerWaitLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_condition = condition;
    let p_query_interval = interval;

    let uri_str = format!(
        "{}/libpod/containers/{name}/wait",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_condition {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("condition".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "condition",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_interval {
        req_builder = req_builder.query(&[("interval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerWaitLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerWaitLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return a live stream of resource usage statistics of one or more container. If no container is specified, the statistics of all containers are returned.
pub async fn containers_stats_all_libpod(
    configuration: &configuration::Configuration,
    containers: Option<Vec<String>>,
    stream: Option<bool>,
    interval: Option<i32>,
) -> Result<ResponseContent<ContainersStatsAllLibpodSuccess>, Error<ContainersStatsAllLibpodError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_containers = containers;
    let p_query_stream = stream;
    let p_query_interval = interval;

    let uri_str = format!("{}/libpod/containers/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_containers {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("containers".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "containers",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_interval {
        req_builder = req_builder.query(&[("interval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainersStatsAllLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainersStatsAllLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Generate Kubernetes YAML based on a pod or container.
pub async fn generate_kube_libpod(
    configuration: &configuration::Configuration,
    names: Vec<String>,
    service: Option<bool>,
) -> Result<reqwest::Response, Error<GenerateKubeLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_names = names;
    let p_query_service = service;

    let uri_str = format!("{}/libpod/generate/kube", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(
            &p_query_names
                .into_iter()
                .map(|p| ("names".to_owned(), p.to_string()))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => req_builder.query(&[(
            "names",
            &p_query_names
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    if let Some(ref param_value) = p_query_service {
        req_builder = req_builder.query(&[("service", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateKubeLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Generate Systemd Units based on a pod or container.
pub async fn generate_systemd_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    use_name: Option<bool>,
    new: Option<bool>,
    no_header: Option<bool>,
    start_timeout: Option<i32>,
    stop_timeout: Option<i32>,
    restart_policy: Option<&str>,
    container_prefix: Option<&str>,
    pod_prefix: Option<&str>,
    separator: Option<&str>,
    restart_sec: Option<i32>,
    wants: Option<Vec<String>>,
    after: Option<Vec<String>>,
    requires: Option<Vec<String>>,
) -> Result<ResponseContent<GenerateSystemdLibpodSuccess>, Error<GenerateSystemdLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_use_name = use_name;
    let p_query_new = new;
    let p_query_no_header = no_header;
    let p_query_start_timeout = start_timeout;
    let p_query_stop_timeout = stop_timeout;
    let p_query_restart_policy = restart_policy;
    let p_query_container_prefix = container_prefix;
    let p_query_pod_prefix = pod_prefix;
    let p_query_separator = separator;
    let p_query_restart_sec = restart_sec;
    let p_query_wants = wants;
    let p_query_after = after;
    let p_query_requires = requires;

    let uri_str = format!(
        "{}/libpod/generate/{name}/systemd",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_use_name {
        req_builder = req_builder.query(&[("useName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_new {
        req_builder = req_builder.query(&[("new", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_header {
        req_builder = req_builder.query(&[("noHeader", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_timeout {
        req_builder = req_builder.query(&[("startTimeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stop_timeout {
        req_builder = req_builder.query(&[("stopTimeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_restart_policy {
        req_builder = req_builder.query(&[("restartPolicy", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_container_prefix {
        req_builder = req_builder.query(&[("containerPrefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pod_prefix {
        req_builder = req_builder.query(&[("podPrefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_separator {
        req_builder = req_builder.query(&[("separator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_restart_sec {
        req_builder = req_builder.query(&[("restartSec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_wants {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("wants".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "wants",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("after".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "after",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_requires {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("requires".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "requires",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GenerateSystemdLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateSystemdLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new image from a container
pub async fn image_commit_libpod(
    configuration: &configuration::Configuration,
    container: &str,
    repo: Option<&str>,
    tag: Option<&str>,
    comment: Option<&str>,
    author: Option<&str>,
    pause: Option<bool>,
    changes: Option<Vec<String>>,
    format: Option<&str>,
) -> Result<ResponseContent<ImageCommitLibpodSuccess>, Error<ImageCommitLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_container = container;
    let p_query_repo = repo;
    let p_query_tag = tag;
    let p_query_comment = comment;
    let p_query_author = author;
    let p_query_pause = pause;
    let p_query_changes = changes;
    let p_query_format = format;

    let uri_str = format!("{}/libpod/commit", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("container", &p_query_container.to_string())]);
    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_comment {
        req_builder = req_builder.query(&[("comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pause {
        req_builder = req_builder.query(&[("pause", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_changes {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("changes".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "changes",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ImageCommitLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ImageCommitLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Tears down pods defined in a YAML file
pub async fn play_kube_down_libpod(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<PlayKubeDownLibpodSuccess>, Error<PlayKubeDownLibpodError>> {
    let uri_str = format!("{}/libpod/play/kube", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PlayKubeDownLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayKubeDownLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create and run pods based on a Kubernetes YAML file (pod or service kind).
pub async fn play_kube_libpod(
    configuration: &configuration::Configuration,
    network: Option<Vec<String>>,
    tls_verify: Option<bool>,
    log_driver: Option<&str>,
    start: Option<bool>,
    static_ips: Option<Vec<String>>,
    static_macs: Option<Vec<String>>,
    request: Option<&str>,
) -> Result<ResponseContent<PlayKubeLibpodSuccess>, Error<PlayKubeLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_network = network;
    let p_query_tls_verify = tls_verify;
    let p_query_log_driver = log_driver;
    let p_query_start = start;
    let p_query_static_ips = static_ips;
    let p_query_static_macs = static_macs;
    let p_body_request = request;

    let uri_str = format!("{}/libpod/play/kube", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_network {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("network".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "network",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_tls_verify {
        req_builder = req_builder.query(&[("tlsVerify", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_log_driver {
        req_builder = req_builder.query(&[("logDriver", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_static_ips {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("staticIPs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "staticIPs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_static_macs {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("staticMACs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "staticMACs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PlayKubeLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayKubeLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Copy a tar archive of files into a container
pub async fn put_container_archive_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    path: &str,
    pause: Option<bool>,
    request: Option<&str>,
) -> Result<ResponseContent<PutContainerArchiveLibpodSuccess>, Error<PutContainerArchiveLibpodError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_path = path;
    let p_query_pause = pause;
    let p_body_request = request;

    let uri_str = format!(
        "{}/libpod/containers/{name}/archive",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_pause {
        req_builder = req_builder.query(&[("pause", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PutContainerArchiveLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PutContainerArchiveLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
