/*
 * Provides an API for the Libpod library
 *
 * This documentation describes the Podman v2.0 RESTful API. It replaces the Podman v1.0 API and was initially delivered along with Podman v2.0.  It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: some fields in the API response JSON are set as omitempty, which means that if there is no value set for them, they will not show up in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v3.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v3.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v3.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: podman@lists.podman.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed successes of method [`generate_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKubeLibpodSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`generate_systemd_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateSystemdLibpodSuccess {
    Status200(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`play_kube_down_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeDownLibpodSuccess {
    Status200(models::PlayKubeReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`play_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeLibpodSuccess {
    Status200(models::PlayKubeReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_create_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodCreateLibpodSuccess {
    Status201(models::IdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodDeleteLibpodSuccess {
    Status200(models::PodRmReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_exists_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodExistsLibpodSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodInspectLibpodSuccess {
    Status200(models::PodInspectLibpod200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_kill_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodKillLibpodSuccess {
    Status200(models::PodKillReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodListLibpodSuccess {
    Status200(Vec<models::ListPodsReport>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_pause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodPauseLibpodSuccess {
    Status200(models::PodPauseReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_prune_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodPruneLibpodSuccess {
    Status200(models::PodPruneReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_restart_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodRestartLibpodSuccess {
    Status200(models::PodRestartReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_start_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStartLibpodSuccess {
    Status200(models::PodStartReport),
    Status304(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_stats_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStatsAllLibpodSuccess {
    Status200(models::ContainerTop200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_stop_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStopLibpodSuccess {
    Status200(models::PodStopReport),
    Status304(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_top_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodTopLibpodSuccess {
    Status200(models::ContainerTop200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`pod_unpause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodUnpauseLibpodSuccess {
    Status200(models::PodUnpauseReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKubeLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_systemd_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateSystemdLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`play_kube_down_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeDownLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`play_kube_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayKubeLibpodError {
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_create_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodCreateLibpodError {
    Status400(models::SystemAuth500Response),
    Status409(String),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodDeleteLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_exists_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodExistsLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodInspectLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_kill_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodKillLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status409(models::PodKillReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodListLibpodError {
    Status400(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_pause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodPauseLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::PodPauseReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_prune_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodPruneLibpodError {
    Status400(models::SystemAuth500Response),
    Status409(),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_restart_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodRestartLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::PodRestartReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_start_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStartLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::PodStartReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_stats_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStatsAllLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_stop_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodStopLibpodError {
    Status400(models::SystemAuth500Response),
    Status404(models::SystemAuth500Response),
    Status409(models::PodStopReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_top_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodTopLibpodError {
    Status404(models::SystemAuth500Response),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pod_unpause_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PodUnpauseLibpodError {
    Status404(models::SystemAuth500Response),
    Status409(models::PodUnpauseReport),
    Status500(models::SystemAuth500Response),
    UnknownValue(serde_json::Value),
}

/// Generate Kubernetes YAML based on a pod or container.
pub async fn generate_kube_libpod(
    configuration: &configuration::Configuration,
    names: Vec<String>,
    service: Option<bool>,
) -> Result<reqwest::Response, Error<GenerateKubeLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_names = names;
    let p_query_service = service;

    let uri_str = format!("{}/libpod/generate/kube", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(
            &p_query_names
                .into_iter()
                .map(|p| ("names".to_owned(), p.to_string()))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => req_builder.query(&[(
            "names",
            &p_query_names
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    if let Some(ref param_value) = p_query_service {
        req_builder = req_builder.query(&[("service", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateKubeLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Generate Systemd Units based on a pod or container.
pub async fn generate_systemd_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    use_name: Option<bool>,
    new: Option<bool>,
    no_header: Option<bool>,
    start_timeout: Option<i32>,
    stop_timeout: Option<i32>,
    restart_policy: Option<&str>,
    container_prefix: Option<&str>,
    pod_prefix: Option<&str>,
    separator: Option<&str>,
    restart_sec: Option<i32>,
    wants: Option<Vec<String>>,
    after: Option<Vec<String>>,
    requires: Option<Vec<String>>,
) -> Result<ResponseContent<GenerateSystemdLibpodSuccess>, Error<GenerateSystemdLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_use_name = use_name;
    let p_query_new = new;
    let p_query_no_header = no_header;
    let p_query_start_timeout = start_timeout;
    let p_query_stop_timeout = stop_timeout;
    let p_query_restart_policy = restart_policy;
    let p_query_container_prefix = container_prefix;
    let p_query_pod_prefix = pod_prefix;
    let p_query_separator = separator;
    let p_query_restart_sec = restart_sec;
    let p_query_wants = wants;
    let p_query_after = after;
    let p_query_requires = requires;

    let uri_str = format!(
        "{}/libpod/generate/{name}/systemd",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_use_name {
        req_builder = req_builder.query(&[("useName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_new {
        req_builder = req_builder.query(&[("new", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_header {
        req_builder = req_builder.query(&[("noHeader", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_timeout {
        req_builder = req_builder.query(&[("startTimeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stop_timeout {
        req_builder = req_builder.query(&[("stopTimeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_restart_policy {
        req_builder = req_builder.query(&[("restartPolicy", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_container_prefix {
        req_builder = req_builder.query(&[("containerPrefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pod_prefix {
        req_builder = req_builder.query(&[("podPrefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_separator {
        req_builder = req_builder.query(&[("separator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_restart_sec {
        req_builder = req_builder.query(&[("restartSec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_wants {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("wants".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "wants",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("after".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "after",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_requires {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("requires".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "requires",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GenerateSystemdLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateSystemdLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Tears down pods defined in a YAML file
pub async fn play_kube_down_libpod(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<PlayKubeDownLibpodSuccess>, Error<PlayKubeDownLibpodError>> {
    let uri_str = format!("{}/libpod/play/kube", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PlayKubeDownLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayKubeDownLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create and run pods based on a Kubernetes YAML file (pod or service kind).
pub async fn play_kube_libpod(
    configuration: &configuration::Configuration,
    network: Option<Vec<String>>,
    tls_verify: Option<bool>,
    log_driver: Option<&str>,
    start: Option<bool>,
    static_ips: Option<Vec<String>>,
    static_macs: Option<Vec<String>>,
    request: Option<&str>,
) -> Result<ResponseContent<PlayKubeLibpodSuccess>, Error<PlayKubeLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_network = network;
    let p_query_tls_verify = tls_verify;
    let p_query_log_driver = log_driver;
    let p_query_start = start;
    let p_query_static_ips = static_ips;
    let p_query_static_macs = static_macs;
    let p_body_request = request;

    let uri_str = format!("{}/libpod/play/kube", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_network {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("network".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "network",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_tls_verify {
        req_builder = req_builder.query(&[("tlsVerify", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_log_driver {
        req_builder = req_builder.query(&[("logDriver", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_static_ips {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("staticIPs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "staticIPs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_static_macs {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("staticMACs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "staticMACs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PlayKubeLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayKubeLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_create_libpod(
    configuration: &configuration::Configuration,
    create: Option<models::PodSpecGenerator>,
) -> Result<ResponseContent<PodCreateLibpodSuccess>, Error<PodCreateLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create = create;

    let uri_str = format!("{}/libpod/pods/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodCreateLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodCreateLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_delete_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    force: Option<bool>,
) -> Result<ResponseContent<PodDeleteLibpodSuccess>, Error<PodDeleteLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_force = force;

    let uri_str = format!(
        "{}/libpod/pods/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodDeleteLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodDeleteLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check if a pod exists by name or ID
pub async fn pod_exists_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodExistsLibpodSuccess>, Error<PodExistsLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/exists",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodExistsLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodExistsLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_inspect_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodInspectLibpodSuccess>, Error<PodInspectLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/json",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodInspectLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodInspectLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_kill_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    signal: Option<&str>,
) -> Result<ResponseContent<PodKillLibpodSuccess>, Error<PodKillLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_signal = signal;

    let uri_str = format!(
        "{}/libpod/pods/{name}/kill",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_signal {
        req_builder = req_builder.query(&[("signal", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodKillLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodKillLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_list_libpod(
    configuration: &configuration::Configuration,
    filters: Option<&str>,
) -> Result<ResponseContent<PodListLibpodSuccess>, Error<PodListLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filters = filters;

    let uri_str = format!("{}/libpod/pods/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodListLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodListLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Pause a pod
pub async fn pod_pause_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodPauseLibpodSuccess>, Error<PodPauseLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/pause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodPauseLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodPauseLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_prune_libpod(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<PodPruneLibpodSuccess>, Error<PodPruneLibpodError>> {
    let uri_str = format!("{}/libpod/pods/prune", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodPruneLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodPruneLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_restart_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodRestartLibpodSuccess>, Error<PodRestartLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/restart",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodRestartLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodRestartLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_start_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodStartLibpodSuccess>, Error<PodStartLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/start",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodStartLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodStartLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Display a live stream of resource usage statistics for the containers in one or more pods
pub async fn pod_stats_all_libpod(
    configuration: &configuration::Configuration,
    all: Option<bool>,
    names_or_ids: Option<Vec<String>>,
) -> Result<ResponseContent<PodStatsAllLibpodSuccess>, Error<PodStatsAllLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_all = all;
    let p_query_names_or_ids = names_or_ids;

    let uri_str = format!("{}/libpod/pods/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_names_or_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("namesOrIDs".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "namesOrIDs",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodStatsAllLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodStatsAllLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_stop_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    t: Option<i32>,
) -> Result<ResponseContent<PodStopLibpodSuccess>, Error<PodStopLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_t = t;

    let uri_str = format!(
        "{}/libpod/pods/{name}/stop",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_t {
        req_builder = req_builder.query(&[("t", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodStopLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodStopLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List processes running inside a pod
pub async fn pod_top_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    stream: Option<bool>,
    delay: Option<i32>,
    ps_args: Option<&str>,
) -> Result<ResponseContent<PodTopLibpodSuccess>, Error<PodTopLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_stream = stream;
    let p_query_delay = delay;
    let p_query_ps_args = ps_args;

    let uri_str = format!(
        "{}/libpod/pods/{name}/top",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_delay {
        req_builder = req_builder.query(&[("delay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ps_args {
        req_builder = req_builder.query(&[("ps_args", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodTopLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodTopLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn pod_unpause_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<PodUnpauseLibpodSuccess>, Error<PodUnpauseLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/pods/{name}/unpause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PodUnpauseLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PodUnpauseLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
