/*
 * supports a RESTful API for the Libpod library
 *
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podman’s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed successes of method [`container_archive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerArchiveSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_archive_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerArchiveLibpodSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_attach`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerAttachSuccess {
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_changes_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerChangesLibpodSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCreateSuccess {
    Status201(models::ContainerCreateResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerDeleteSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExportSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_inspect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInspectSuccess {
    Status200(models::InspectResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_kill`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerKillSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerListSuccess {
    Status200(Vec<models::Container>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerLogsSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_pause`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPauseSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_prune`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPruneSuccess {
    Status200(Vec<models::ContainersPruneReport>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_rename`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRenameSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_resize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerResizeSuccess {
    Status200(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_restart`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestartSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_start`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStartSuccess {
    Status204(),
    Status304(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStatsSuccess {
    Status200(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStopSuccess {
    Status204(),
    Status304(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_top`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerTopSuccess {
    Status200(models::ContainerTopOkBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_unpause`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnpauseSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUpdateSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`container_wait`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerWaitSuccess {
    Status200(models::ContainerWait200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`image_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImageCommitSuccess {
    Status201(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`put_container_archive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutContainerArchiveSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_archive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerArchiveError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_archive_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerArchiveLibpodError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_attach`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerAttachError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_changes_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerChangesLibpodError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerCreateError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status409(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerDeleteError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status409(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerExportError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_inspect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerInspectError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_kill`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerKillError {
    Status404(models::ErrorModel),
    Status409(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerListError {
    Status400(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerLogsError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_pause`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPauseError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_prune`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerPruneError {
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_rename`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRenameError {
    Status404(models::ErrorModel),
    Status409(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_resize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerResizeError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_restart`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerRestartError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_start`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStartError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStatsError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerStopError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_top`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerTopError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_unpause`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUnpauseError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerUpdateError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`container_wait`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContainerWaitError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`image_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImageCommitError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_container_archive`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutContainerArchiveError {
    Status400(models::ErrorModel),
    Status403(),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// Get a tar archive of files from a container
pub async fn container_archive(
    configuration: &configuration::Configuration,
    name: &str,
    path: &str,
) -> Result<reqwest::Response, Error<ContainerArchiveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_path = path;

    let uri_str = format!(
        "{}/containers/{name}/archive",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerArchiveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Copy a tar archive of files from a container
pub async fn container_archive_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    path: &str,
    rename: Option<&str>,
) -> Result<reqwest::Response, Error<ContainerArchiveLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_path = path;
    let p_query_rename = rename;

    let uri_str = format!(
        "{}/libpod/containers/{name}/archive",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_rename {
        req_builder = req_builder.query(&[("rename", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerArchiveLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  It uses the same stream format as docker, see the libpod attach endpoint for a description of the format.
pub async fn container_attach(
    configuration: &configuration::Configuration,
    name: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    stdin: Option<bool>,
) -> Result<ResponseContent<ContainerAttachSuccess>, Error<ContainerAttachError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_detach_keys = detach_keys;
    let p_query_logs = logs;
    let p_query_stream = stream;
    let p_query_stdout = stdout;
    let p_query_stderr = stderr;
    let p_query_stdin = stdin;

    let uri_str = format!(
        "{}/containers/{name}/attach",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_detach_keys {
        req_builder = req_builder.query(&[("detachKeys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_logs {
        req_builder = req_builder.query(&[("logs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdout {
        req_builder = req_builder.query(&[("stdout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stderr {
        req_builder = req_builder.query(&[("stderr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdin {
        req_builder = req_builder.query(&[("stdin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerAttachSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerAttachError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns which files in a container's filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted
pub async fn container_changes_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    parent: Option<&str>,
    diff_type: Option<&str>,
) -> Result<ResponseContent<ContainerChangesLibpodSuccess>, Error<ContainerChangesLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_parent = parent;
    let p_query_diff_type = diff_type;

    let uri_str = format!(
        "{}/libpod/containers/{name}/changes",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_parent {
        req_builder = req_builder.query(&[("parent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diff_type {
        req_builder = req_builder.query(&[("diffType", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerChangesLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerChangesLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_create(
    configuration: &configuration::Configuration,
    body: models::CreateContainerConfig,
    name: Option<&str>,
) -> Result<ResponseContent<ContainerCreateSuccess>, Error<ContainerCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_query_name = name;

    let uri_str = format!("{}/containers/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerCreateSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_delete(
    configuration: &configuration::Configuration,
    name: &str,
    force: Option<bool>,
    v: Option<bool>,
    link: Option<bool>,
) -> Result<ResponseContent<ContainerDeleteSuccess>, Error<ContainerDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_force = force;
    let p_query_v = v;
    let p_query_link = link;

    let uri_str = format!(
        "{}/containers/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_v {
        req_builder = req_builder.query(&[("v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_link {
        req_builder = req_builder.query(&[("link", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerDeleteSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Export the contents of a container as a tarball.
pub async fn container_export(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerExportSuccess>, Error<ContainerExportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/containers/{name}/export",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerExportSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerExportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return low-level information about a container.
pub async fn container_inspect(
    configuration: &configuration::Configuration,
    name: &str,
    size: Option<bool>,
) -> Result<ResponseContent<ContainerInspectSuccess>, Error<ContainerInspectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_size = size;

    let uri_str = format!(
        "{}/containers/{name}/json",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerInspectSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerInspectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Signal to send to the container as an integer or string (e.g. SIGINT)
pub async fn container_kill(
    configuration: &configuration::Configuration,
    name: &str,
    all: Option<bool>,
    signal: Option<&str>,
) -> Result<ResponseContent<ContainerKillSuccess>, Error<ContainerKillError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_all = all;
    let p_query_signal = signal;

    let uri_str = format!(
        "{}/containers/{name}/kill",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signal {
        req_builder = req_builder.query(&[("signal", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerKillSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerKillError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of containers
pub async fn container_list(
    configuration: &configuration::Configuration,
    all: Option<bool>,
    external: Option<bool>,
    limit: Option<i32>,
    size: Option<bool>,
    filters: Option<&str>,
) -> Result<ResponseContent<ContainerListSuccess>, Error<ContainerListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_all = all;
    let p_query_external = external;
    let p_query_limit = limit;
    let p_query_size = size;
    let p_query_filters = filters;

    let uri_str = format!("{}/containers/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external {
        req_builder = req_builder.query(&[("external", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerListSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get stdout and stderr logs from a container.
pub async fn container_logs(
    configuration: &configuration::Configuration,
    name: &str,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<&str>,
    until: Option<&str>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ResponseContent<ContainerLogsSuccess>, Error<ContainerLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_follow = follow;
    let p_query_stdout = stdout;
    let p_query_stderr = stderr;
    let p_query_since = since;
    let p_query_until = until;
    let p_query_timestamps = timestamps;
    let p_query_tail = tail;

    let uri_str = format!(
        "{}/containers/{name}/logs",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stdout {
        req_builder = req_builder.query(&[("stdout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stderr {
        req_builder = req_builder.query(&[("stderr", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_until {
        req_builder = req_builder.query(&[("until", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timestamps {
        req_builder = req_builder.query(&[("timestamps", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tail {
        req_builder = req_builder.query(&[("tail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerLogsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Use the cgroups freezer to suspend all processes in a container.
pub async fn container_pause(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerPauseSuccess>, Error<ContainerPauseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/containers/{name}/pause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerPauseSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerPauseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove containers not in use
pub async fn container_prune(
    configuration: &configuration::Configuration,
    filters: Option<&str>,
) -> Result<ResponseContent<ContainerPruneSuccess>, Error<ContainerPruneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filters = filters;

    let uri_str = format!("{}/containers/prune", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerPruneSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerPruneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Change the name of an existing container.
pub async fn container_rename(
    configuration: &configuration::Configuration,
    name: &str,
    name2: &str,
) -> Result<ResponseContent<ContainerRenameSuccess>, Error<ContainerRenameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_name = name2;

    let uri_str = format!(
        "{}/containers/{name}/rename",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerRenameSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerRenameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resize the terminal attached to a container (for use with Attach).
pub async fn container_resize(
    configuration: &configuration::Configuration,
    name: &str,
    h: Option<i32>,
    w: Option<i32>,
    running: Option<bool>,
) -> Result<ResponseContent<ContainerResizeSuccess>, Error<ContainerResizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_h = h;
    let p_query_w = w;
    let p_query_running = running;

    let uri_str = format!(
        "{}/containers/{name}/resize",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_h {
        req_builder = req_builder.query(&[("h", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_w {
        req_builder = req_builder.query(&[("w", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_running {
        req_builder = req_builder.query(&[("running", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerResizeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerResizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_restart(
    configuration: &configuration::Configuration,
    name: &str,
    t: Option<i32>,
) -> Result<ResponseContent<ContainerRestartSuccess>, Error<ContainerRestartError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_t = t;

    let uri_str = format!(
        "{}/containers/{name}/restart",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_t {
        req_builder = req_builder.query(&[("t", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerRestartSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerRestartError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_start(
    configuration: &configuration::Configuration,
    name: &str,
    detach_keys: Option<&str>,
) -> Result<ResponseContent<ContainerStartSuccess>, Error<ContainerStartError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_detach_keys = detach_keys;

    let uri_str = format!(
        "{}/containers/{name}/start",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_detach_keys {
        req_builder = req_builder.query(&[("detachKeys", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStartSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStartError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// This returns a live stream of a container’s resource usage statistics.
pub async fn container_stats(
    configuration: &configuration::Configuration,
    name: &str,
    stream: Option<bool>,
    one_shot: Option<bool>,
) -> Result<ResponseContent<ContainerStatsSuccess>, Error<ContainerStatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_stream = stream;
    let p_query_one_shot = one_shot;

    let uri_str = format!(
        "{}/containers/{name}/stats",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream {
        req_builder = req_builder.query(&[("stream", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_one_shot {
        req_builder = req_builder.query(&[("one-shot", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStatsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Stop a container
pub async fn container_stop(
    configuration: &configuration::Configuration,
    name: &str,
    t: Option<i32>,
) -> Result<ResponseContent<ContainerStopSuccess>, Error<ContainerStopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_t = t;

    let uri_str = format!(
        "{}/containers/{name}/stop",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_t {
        req_builder = req_builder.query(&[("t", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerStopSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerStopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn container_top(
    configuration: &configuration::Configuration,
    name: &str,
    ps_args: Option<&str>,
) -> Result<ResponseContent<ContainerTopSuccess>, Error<ContainerTopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_ps_args = ps_args;

    let uri_str = format!(
        "{}/containers/{name}/top",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ps_args {
        req_builder = req_builder.query(&[("ps_args", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerTopSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerTopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resume a paused container
pub async fn container_unpause(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ContainerUnpauseSuccess>, Error<ContainerUnpauseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/containers/{name}/unpause",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerUnpauseSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerUnpauseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Change configuration settings for an existing container without requiring recreation.
pub async fn container_update(
    configuration: &configuration::Configuration,
    name: &str,
    resources: Option<models::ContainerUpdateRequest>,
) -> Result<ResponseContent<ContainerUpdateSuccess>, Error<ContainerUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_resources = resources;

    let uri_str = format!(
        "{}/containers/{name}/update",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_resources);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerUpdateSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Block until a container stops or given condition is met.
pub async fn container_wait(
    configuration: &configuration::Configuration,
    name: &str,
    condition: Option<&str>,
    interval: Option<&str>,
) -> Result<ResponseContent<ContainerWaitSuccess>, Error<ContainerWaitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_condition = condition;
    let p_query_interval = interval;

    let uri_str = format!(
        "{}/containers/{name}/wait",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_condition {
        req_builder = req_builder.query(&[("condition", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_interval {
        req_builder = req_builder.query(&[("interval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ContainerWaitSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ContainerWaitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new image from a container
pub async fn image_commit(
    configuration: &configuration::Configuration,
    container: Option<&str>,
    repo: Option<&str>,
    tag: Option<&str>,
    comment: Option<&str>,
    author: Option<&str>,
    pause: Option<bool>,
    changes: Option<&str>,
    squash: Option<bool>,
) -> Result<ResponseContent<ImageCommitSuccess>, Error<ImageCommitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_container = container;
    let p_query_repo = repo;
    let p_query_tag = tag;
    let p_query_comment = comment;
    let p_query_author = author;
    let p_query_pause = pause;
    let p_query_changes = changes;
    let p_query_squash = squash;

    let uri_str = format!("{}/commit", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_container {
        req_builder = req_builder.query(&[("container", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_comment {
        req_builder = req_builder.query(&[("comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pause {
        req_builder = req_builder.query(&[("pause", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_changes {
        req_builder = req_builder.query(&[("changes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_squash {
        req_builder = req_builder.query(&[("squash", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ImageCommitSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ImageCommitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Put a tar archive of files into a container
pub async fn put_container_archive(
    configuration: &configuration::Configuration,
    name: &str,
    path: &str,
    no_overwrite_dir_non_dir: Option<&str>,
    copy_uidgid: Option<&str>,
    request: Option<&str>,
) -> Result<ResponseContent<PutContainerArchiveSuccess>, Error<PutContainerArchiveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_path = path;
    let p_query_no_overwrite_dir_non_dir = no_overwrite_dir_non_dir;
    let p_query_copy_uidgid = copy_uidgid;
    let p_body_request = request;

    let uri_str = format!(
        "{}/containers/{name}/archive",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_no_overwrite_dir_non_dir {
        req_builder = req_builder.query(&[("noOverwriteDirNonDir", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_copy_uidgid {
        req_builder = req_builder.query(&[("copyUIDGID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<PutContainerArchiveSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<PutContainerArchiveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
