/*
 * supports a RESTful API for the Libpod library
 *
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};

/// struct for typed successes of method [`artifact_add_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactAddLibpodSuccess {
    Status201(models::ArtifactAddReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_delete_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactDeleteAllLibpodSuccess {
    Status200(models::ArtifactRemoveReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactDeleteLibpodSuccess {
    Status200(models::ArtifactRemoveReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_extract_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactExtractLibpodSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactInspectLibpodSuccess {
    Status200(models::ArtifactInspectReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactListLibpodSuccess {
    Status200(Vec<models::ArtifactListReport>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_pull_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactPullLibpodSuccess {
    Status200(models::ArtifactPullReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`artifact_push_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactPushLibpodSuccess {
    Status200(models::ArtifactPushReport),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_add_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactAddLibpodError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_delete_all_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactDeleteAllLibpodError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_delete_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactDeleteLibpodError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_extract_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactExtractLibpodError {
    Status400(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_inspect_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactInspectLibpodError {
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_list_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactListLibpodError {
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_pull_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactPullLibpodError {
    Status400(models::ErrorModel),
    Status401(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`artifact_push_libpod`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArtifactPushLibpodError {
    Status400(models::ErrorModel),
    Status401(models::ErrorModel),
    Status404(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// Add a file as a new OCI artifact, or append to an existing artifact if 'append' is true.
pub async fn artifact_add_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    file_name: &str,
    file_mime_type: Option<&str>,
    annotations: Option<Vec<String>>,
    artifact_mime_type: Option<&str>,
    append: Option<bool>,
    replace: Option<bool>,
    input_stream: Option<std::path::PathBuf>,
) -> Result<ResponseContent<ArtifactAddLibpodSuccess>, Error<ArtifactAddLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_file_name = file_name;
    let p_query_file_mime_type = file_mime_type;
    let p_query_annotations = annotations;
    let p_query_artifact_mime_type = artifact_mime_type;
    let p_query_append = append;
    let p_query_replace = replace;
    let p_body_input_stream = input_stream;

    let uri_str = format!("{}/libpod/artifacts/add", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    req_builder = req_builder.query(&[("fileName", &p_query_file_name.to_string())]);
    if let Some(ref param_value) = p_query_file_mime_type {
        req_builder = req_builder.query(&[("fileMIMEType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_annotations {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("annotations".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotations",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_artifact_mime_type {
        req_builder = req_builder.query(&[("artifactMIMEType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_append {
        req_builder = req_builder.query(&[("append", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_body_input_stream {
        let file = TokioFile::open(param_value).await?;
        let stream = FramedRead::new(file, BytesCodec::new());
        req_builder = req_builder.body(reqwest::Body::wrap_stream(stream));
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactAddLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactAddLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove one or more OCI artifacts from local storage. Can be filtered by name/ID or all artifacts can be removed.
pub async fn artifact_delete_all_libpod(
    configuration: &configuration::Configuration,
    artifacts: Option<Vec<String>>,
    all: Option<bool>,
    ignore: Option<bool>,
) -> Result<ResponseContent<ArtifactDeleteAllLibpodSuccess>, Error<ArtifactDeleteAllLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_artifacts = artifacts;
    let p_query_all = all;
    let p_query_ignore = ignore;

    let uri_str = format!("{}/libpod/artifacts/remove", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_artifacts {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("artifacts".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "artifacts",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore {
        req_builder = req_builder.query(&[("ignore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactDeleteAllLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactDeleteAllLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove a single artifact from local storage by name or ID.
pub async fn artifact_delete_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ArtifactDeleteLibpodSuccess>, Error<ArtifactDeleteLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/artifacts/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactDeleteLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactDeleteLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Extract the files of an OCI artifact to the local filesystem as a tar archive.
pub async fn artifact_extract_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    title: Option<&str>,
    digest: Option<&str>,
    exclude_title: Option<bool>,
) -> Result<reqwest::Response, Error<ArtifactExtractLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_title = title;
    let p_query_digest = digest;
    let p_query_exclude_title = exclude_title;

    let uri_str = format!(
        "{}/libpod/artifacts/{name}/extract",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_digest {
        req_builder = req_builder.query(&[("digest", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exclude_title {
        req_builder = req_builder.query(&[("excludeTitle", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactExtractLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve detailed information about a specific OCI artifact by name or ID.
pub async fn artifact_inspect_libpod(
    configuration: &configuration::Configuration,
    name: &str,
) -> Result<ResponseContent<ArtifactInspectLibpodSuccess>, Error<ArtifactInspectLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!(
        "{}/libpod/artifacts/{name}/json",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactInspectLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactInspectLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return a list of all OCI artifacts in local storage.
pub async fn artifact_list_libpod(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<ArtifactListLibpodSuccess>, Error<ArtifactListLibpodError>> {
    let uri_str = format!("{}/libpod/artifacts/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactListLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactListLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Pull an OCI artifact from a remote registry to local storage.
pub async fn artifact_pull_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    retry: Option<i32>,
    retry_delay: Option<&str>,
    tls_verify: Option<bool>,
    x_registry_auth: Option<&str>,
) -> Result<ResponseContent<ArtifactPullLibpodSuccess>, Error<ArtifactPullLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_retry = retry;
    let p_query_retry_delay = retry_delay;
    let p_query_tls_verify = tls_verify;
    let p_header_x_registry_auth = x_registry_auth;

    let uri_str = format!("{}/libpod/artifacts/pull", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref param_value) = p_query_retry {
        req_builder = req_builder.query(&[("retry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retry_delay {
        req_builder = req_builder.query(&[("retryDelay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_verify {
        req_builder = req_builder.query(&[("tlsVerify", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_registry_auth {
        req_builder = req_builder.header("X-Registry-Auth", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactPullLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactPullLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Push an OCI artifact from local storage to a remote image registry.
pub async fn artifact_push_libpod(
    configuration: &configuration::Configuration,
    name: &str,
    retry: Option<i32>,
    retry_delay: Option<&str>,
    tls_verify: Option<bool>,
    x_registry_auth: Option<&str>,
) -> Result<ResponseContent<ArtifactPushLibpodSuccess>, Error<ArtifactPushLibpodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_retry = retry;
    let p_query_retry_delay = retry_delay;
    let p_query_tls_verify = tls_verify;
    let p_header_x_registry_auth = x_registry_auth;

    let uri_str = format!(
        "{}/libpod/artifacts/{name}/push",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_retry {
        req_builder = req_builder.query(&[("retry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retry_delay {
        req_builder = req_builder.query(&[("retryDelay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_verify {
        req_builder = req_builder.query(&[("tlsVerify", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_registry_auth {
        req_builder = req_builder.header("X-Registry-Auth", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ArtifactPushLibpodSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ArtifactPushLibpodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
